{"version":3,"sources":["slice.js"],"names":[],"mappings":";;;;;;;;yBAAsB,YAAY;;;;kCACH,sBAAsB;;;;4BAClC,eAAe;;;;;;;;;;;qBAQnB,UAAC,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAK;AAC5C,QAAI,iBAAiB,YAAA;QACjB,wBAAwB,YAAA;QACxB,cAAc,YAAA;QACd,UAAU,YAAA;QACV,uBAAuB,YAAA;QACvB,UAAU,YAAA;QACV,WAAW,YAAA,CAAC;;AAEhB,cAAU,GAAG,4BAAU,KAAK,CAAC,CAAC;;;;AAI9B,qBAAiB,GAAG,qCAAmB,KAAK,CAAC,CAAC;;;;AAI9C,4BAAwB,GAAG,iBAAiB,CAAC,OAAO,EAAE,CAAC;;;;AAIvD,eAAW,GAAG,UAAU,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;;;;AAIrD,2BAAuB,GAAG,UAAU,GAAG,WAAW,CAAC,MAAM,CAAC;;;;AAI1D,cAAU,GAAG,IAAI,CAAC;;AAElB,4BAAwB,CAAC,OAAO,CAAC,UAAC,UAAU,EAAK;AAC7C,YAAI,WAAW,YAAA,CAAC;;AAEhB,YAAI,UAAU,CAAC,KAAK,GAAG,uBAAuB,EAAE;AAC5C,mBAAO;SACV;;AAED,mBAAW,GAAG,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC;;AAE5C,YAAI,WAAW,IAAI,CAAC,EAAE;AAClB,gBAAI,CAAC,UAAU,EAAE;AACb,uBAAO;aACV;;AAED,sBAAU,GAAG,KAAK,CAAC;;AAEnB,uBAAW,GAAG,CAAC,CAAC;SACnB;;;;;;;;;AASD,mBAAW,GAAG,+BAAO,WAAW,EAAE,WAAW,EAAE,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;KACtE,CAAC,CAAC;;;;AAIH,QAAI,cAAc,iBAAiB,IAAI,wBAAwB,CAAC,MAAM,IAAI,wBAAwB,CAAC,CAAC,CAAC,CAAC,IAAI,iBAAiB,EAAE;AACzH,mBAAW,gBAAgB,CAAC;KAC/B;;AAED,WAAO,WAAW,CAAC;CACtB","file":"slice.js","sourcesContent":["import stripANSI from 'strip-ansi';\nimport mapANSIEscapeCodes from './mapANSIEscapeCodes';\nimport splice from 'splice-string';\n\n/**\n * @param {String} input\n * @param {Number} beginSlice The zero-based index at which to begin extraction.\n * @param {Number} endSlice Optional. The zero-based index at which to end extraction.\n * @return {String}\n */\nexport default (input, beginSlice, endSlice) => {\n    let ANSIEscapeCodeMap,\n        ReverseANSIEscapeCodeMap,\n        lastEscapeCode,\n        noNegative,\n        offsetSlicedInputLength,\n        plainInput,\n        slicedInput;\n\n    plainInput = stripANSI(input);\n\n    // console.log(`plainInput`, plainInput);\n\n    ANSIEscapeCodeMap = mapANSIEscapeCodes(input);\n\n    // console.log(`ANSIEscapeCodeMap`, ANSIEscapeCodeMap);\n\n    ReverseANSIEscapeCodeMap = ANSIEscapeCodeMap.reverse();\n\n    // console.log(`\\nReverseANSIEscapeCodeMap:\\n\\n`, ReverseANSIEscapeCodeMap, `\\n`);\n\n    slicedInput = plainInput.slice(beginSlice, endSlice);\n\n    // console.log(`slicedInput`, slicedInput);\n\n    offsetSlicedInputLength = beginSlice + slicedInput.length;\n\n    // console.log(`slicedInputLength`, offsetSlicedInputLength);\n\n    noNegative = true;\n\n    ReverseANSIEscapeCodeMap.forEach((escapeCode) => {\n        let offsetIndex;\n\n        if (escapeCode.index > offsetSlicedInputLength) {\n            return;\n        }\n\n        offsetIndex = escapeCode.index - beginSlice;\n\n        if (offsetIndex <= 0) {\n            if (!noNegative) {\n                return;\n            }\n\n            noNegative = false;\n\n            offsetIndex = 0;\n        }\n\n        /* escapeCode.code = escapeCode.code\n            .replace(\"\\u001b[34m\", '{blue}')\n            .replace(\"\\u001b[39m\", '{reset}')\n            .replace(\"\\u001b[31m\", '{red}'); */\n\n        // console.log(`escapeCode`, JSON.stringify(escapeCode));\n\n        slicedInput = splice(slicedInput, offsetIndex, 0, escapeCode.code);\n    });\n\n    // This logic is specific to https://github.com/chalk/chalk implementation.\n    // `chalk` ends every string with `\\u001b[31m`.\n    if (lastEscapeCode !== `\\u001b[39m` && ReverseANSIEscapeCodeMap.length && ReverseANSIEscapeCodeMap[0].code === `\\u001b[39m`) {\n        slicedInput += `\\u001b[39m`;\n    }\n\n    return slicedInput;\n};\n"],"sourceRoot":"/source/"}