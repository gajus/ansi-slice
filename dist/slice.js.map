{"version":3,"sources":["slice.js"],"names":[],"mappings":";;;;;;;;yBAAsB,YAAY;;;;4BACf,eAAe;;;;yBACL,YAAY;;;;kCACV,sBAAsB;;;;oBACpC,QAAQ;;;;qBACP,SAAS;;;;AAE3B,IAAI,SAAS,YAAA,CAAC;;AAEd,SAAS,GAAG,6BAAkB,CAAC;;;;;;;;;qBAQhB,UAAC,OAAO,EAAE,UAAU,EAAM,QAAQ,EAAK;QAA7B,UAAU,gBAAV,UAAU,GAAG,CAAC;;AACnC,QAAI,iBAAiB,YAAA;QACjB,wBAAwB,YAAA;QACxB,UAAU,YAAA;QACV,yBAAyB,YAAA;QACzB,YAAY,YAAA;QACZ,aAAa,YAAA;QACb,iBAAiB,YAAA,CAAC;;AAEtB,qBAAiB,GAAG,KAAK,CAAC;;AAE1B,QAAI,OAAO,OAAO,aAAa,EAAE;AAC7B,cAAM,IAAI,KAAK,wCAAwC,CAAC;KAC3D;;AAED,gBAAY,GAAG,4BAAU,OAAO,CAAC,CAAC;;;;AAIlC,qBAAiB,GAAG,qCAAmB,OAAO,CAAC,CAAC;;;;AAIhD,4BAAwB,GAAG,iBAAiB,CAAC,OAAO,EAAE,CAAC;;;;AAIvD,iBAAa,GAAG,YAAY,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;;;;AAIzD,6BAAyB,GAAG,UAAU,GAAG,aAAa,CAAC,MAAM,CAAC;;;;AAI9D,cAAU,GAAG,IAAI,CAAC;;AAElB,4BAAwB,CAAC,OAAO,CAAC,UAAC,UAAU,EAAK;AAC7C,YAAI,WAAW,YAAA,CAAC;;AAEhB,YAAI,UAAU,CAAC,KAAK,GAAG,yBAAyB,EAAE;AAC9C,mBAAO;SACV;;AAED,yBAAiB,GAAG,IAAI,CAAC;;AAEzB,mBAAW,GAAG,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC;;AAE5C,YAAI,WAAW,GAAG,CAAC,EAAE;;;AAGjB,gBAAI,CAAC,UAAU,EAAE;AACb,uBAAO;aACV;;AAED,sBAAU,GAAG,KAAK,CAAC;;AAEnB,uBAAW,GAAG,CAAC,CAAC;SACnB;;;;;;;;;AASD,qBAAa,GAAG,+BAAO,aAAa,EAAE,WAAW,EAAE,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;KAC1E,CAAC,CAAC;;AAEH,QAAI,iBAAiB,EAAE;AACnB,qBAAa,GAAG,uBAAK,aAAa,EAAE,IAAI,MAAM,CAAI,SAAS,CAAC,MAAM,OAAK,CAAC,CAAC;AACzE,qBAAa,IAAI,yBAAO,CAAC;;KAE5B;;AAED,WAAO,aAAa,CAAC;CACxB","file":"slice.js","sourcesContent":["import stripANSI from 'strip-ansi';\nimport splice from 'splice-string';\nimport ANSIRegexFactory from 'ansi-regex';\nimport mapANSIEscapeCodes from './mapANSIEscapeCodes';\nimport trim from './trim';\nimport close from './close';\n\nlet ANSIRegex;\n\nANSIRegex = ANSIRegexFactory();\n\n/**\n * @param {String} subject\n * @param {Number} beginSlice The zero-based index at which to begin extraction.\n * @param {Number} endSlice Optional. The zero-based index at which to end extraction.\n * @return {String}\n */\nexport default (subject, beginSlice = 0, endSlice) => {\n    let ANSIEscapeCodeMap,\n        ReverseANSIEscapeCodeMap,\n        noNegative,\n        offsetSlicedSubjectLength,\n        plainSubject,\n        slicedSubject,\n        mappedEscapeCodes;\n\n    mappedEscapeCodes = false;\n\n    if (typeof subject !== `string`) {\n        throw new Error(`ansi-slice subject must be a string.`);\n    }\n\n    plainSubject = stripANSI(subject);\n\n    // console.log(`plainSubject`, plainSubject);\n\n    ANSIEscapeCodeMap = mapANSIEscapeCodes(subject);\n\n    // console.log(`ANSIEscapeCodeMap`, ANSIEscapeCodeMap);\n\n    ReverseANSIEscapeCodeMap = ANSIEscapeCodeMap.reverse();\n\n    // console.log(`\\nReverseANSIEscapeCodeMap:\\n\\n`, ReverseANSIEscapeCodeMap, `\\n`);\n\n    slicedSubject = plainSubject.slice(beginSlice, endSlice);\n\n    // console.log(`slicedSubject`, slicedSubject);\n\n    offsetSlicedSubjectLength = beginSlice + slicedSubject.length;\n\n    // console.log(`offsetSlicedSubjectLength`, offsetSlicedSubjectLength);\n\n    noNegative = true;\n\n    ReverseANSIEscapeCodeMap.forEach((escapeCode) => {\n        let offsetIndex;\n\n        if (escapeCode.index > offsetSlicedSubjectLength) {\n            return;\n        }\n\n        mappedEscapeCodes = true;\n\n        offsetIndex = escapeCode.index - beginSlice;\n\n        if (offsetIndex < 0) {\n            // console.log(`offsetIndex`, offsetIndex);\n\n            if (!noNegative) {\n                return;\n            }\n\n            noNegative = false;\n\n            offsetIndex = 0;\n        }\n\n        /* escapeCode.code = escapeCode.code\n            .replace(\"\\u001b[34m\", '{blue}')\n            .replace(\"\\u001b[39m\", '{reset}')\n            .replace(\"\\u001b[31m\", '{red}'); */\n\n        // console.log(`escapeCode`, JSON.stringify(escapeCode));\n\n        slicedSubject = splice(slicedSubject, offsetIndex, 0, escapeCode.code);\n    });\n\n    if (mappedEscapeCodes) {\n        slicedSubject = trim(slicedSubject, new RegExp(`${ANSIRegex.source}\\$`));\n        slicedSubject += close();\n        // slicedSubject += `\\u001b[39m`;\n    }\n\n    return slicedSubject;\n};\n"],"sourceRoot":"/source/"}