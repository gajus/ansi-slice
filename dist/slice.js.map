{"version":3,"sources":["slice.js"],"names":[],"mappings":";;;;;;;;yBAAsB,YAAY;;;;kCACH,sBAAsB;;;;4BAClC,eAAe;;;;;;;;;;;qBAQnB,UAAC,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAK;AAC9C,QAAI,iBAAiB,YAAA;QACjB,wBAAwB,YAAA;QACxB,cAAc,YAAA;QACd,UAAU,YAAA;QACV,yBAAyB,YAAA;QACzB,YAAY,YAAA;QACZ,aAAa,YAAA,CAAC;;AAElB,QAAI,OAAO,OAAO,aAAa,EAAE;AAC7B,cAAM,IAAI,KAAK,wCAAwC,CAAC;KAC3D;;AAED,gBAAY,GAAG,4BAAU,OAAO,CAAC,CAAC;;;;AAIlC,qBAAiB,GAAG,qCAAmB,OAAO,CAAC,CAAC;;;;AAIhD,4BAAwB,GAAG,iBAAiB,CAAC,OAAO,EAAE,CAAC;;;;AAIvD,iBAAa,GAAG,YAAY,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;;;;AAIzD,6BAAyB,GAAG,UAAU,GAAG,aAAa,CAAC,MAAM,CAAC;;;;AAI9D,cAAU,GAAG,IAAI,CAAC;;AAElB,4BAAwB,CAAC,OAAO,CAAC,UAAC,UAAU,EAAK;AAC7C,YAAI,WAAW,YAAA,CAAC;;AAEhB,YAAI,UAAU,CAAC,KAAK,GAAG,yBAAyB,EAAE;AAC9C,mBAAO;SACV;;AAED,mBAAW,GAAG,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC;;AAE5C,YAAI,WAAW,IAAI,CAAC,EAAE;AAClB,gBAAI,CAAC,UAAU,EAAE;AACb,uBAAO;aACV;;AAED,sBAAU,GAAG,KAAK,CAAC;;AAEnB,uBAAW,GAAG,CAAC,CAAC;SACnB;;;;;;;;;AASD,qBAAa,GAAG,+BAAO,aAAa,EAAE,WAAW,EAAE,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;KAC1E,CAAC,CAAC;;;;AAIH,QAAI,cAAc,iBAAiB,IAAI,wBAAwB,CAAC,MAAM,IAAI,wBAAwB,CAAC,CAAC,CAAC,CAAC,IAAI,iBAAiB,EAAE;AACzH,qBAAa,gBAAgB,CAAC;KACjC;;AAED,WAAO,aAAa,CAAC;CACxB","file":"slice.js","sourcesContent":["import stripANSI from 'strip-ansi';\nimport mapANSIEscapeCodes from './mapANSIEscapeCodes';\nimport splice from 'splice-string';\n\n/**\n * @param {String} subject\n * @param {Number} beginSlice The zero-based index at which to begin extraction.\n * @param {Number} endSlice Optional. The zero-based index at which to end extraction.\n * @return {String}\n */\nexport default (subject, beginSlice, endSlice) => {\n    let ANSIEscapeCodeMap,\n        ReverseANSIEscapeCodeMap,\n        lastEscapeCode,\n        noNegative,\n        offsetSlicedSubjectLength,\n        plainSubject,\n        slicedSubject;\n\n    if (typeof subject !== `string`) {\n        throw new Error(`ansi-slice subject must be a string.`);\n    }\n\n    plainSubject = stripANSI(subject);\n\n    // console.log(`plainSubject`, plainSubject);\n\n    ANSIEscapeCodeMap = mapANSIEscapeCodes(subject);\n\n    // console.log(`ANSIEscapeCodeMap`, ANSIEscapeCodeMap);\n\n    ReverseANSIEscapeCodeMap = ANSIEscapeCodeMap.reverse();\n\n    // console.log(`\\nReverseANSIEscapeCodeMap:\\n\\n`, ReverseANSIEscapeCodeMap, `\\n`);\n\n    slicedSubject = plainSubject.slice(beginSlice, endSlice);\n\n    // console.log(`slicedSubject`, slicedSubject);\n\n    offsetSlicedSubjectLength = beginSlice + slicedSubject.length;\n\n    // console.log(`offsetSlicedSubjectLength`, offsetSlicedSubjectLength);\n\n    noNegative = true;\n\n    ReverseANSIEscapeCodeMap.forEach((escapeCode) => {\n        let offsetIndex;\n\n        if (escapeCode.index > offsetSlicedSubjectLength) {\n            return;\n        }\n\n        offsetIndex = escapeCode.index - beginSlice;\n\n        if (offsetIndex <= 0) {\n            if (!noNegative) {\n                return;\n            }\n\n            noNegative = false;\n\n            offsetIndex = 0;\n        }\n\n        /* escapeCode.code = escapeCode.code\n            .replace(\"\\u001b[34m\", '{blue}')\n            .replace(\"\\u001b[39m\", '{reset}')\n            .replace(\"\\u001b[31m\", '{red}'); */\n\n        // console.log(`escapeCode`, JSON.stringify(escapeCode));\n\n        slicedSubject = splice(slicedSubject, offsetIndex, 0, escapeCode.code);\n    });\n\n    // This logic is specific to https://github.com/chalk/chalk implementation.\n    // `chalk` ends every string with `\\u001b[31m`.\n    if (lastEscapeCode !== `\\u001b[39m` && ReverseANSIEscapeCodeMap.length && ReverseANSIEscapeCodeMap[0].code === `\\u001b[39m`) {\n        slicedSubject += `\\u001b[39m`;\n    }\n\n    return slicedSubject;\n};\n"],"sourceRoot":"/source/"}